use clap::Parser;
use rand::{rngs::OsRng, TryRngCore}; // needed for salt
use rayon::join;
use std::io::{self, Read};
use yescrypt::{CustomizedPasswordHasher, Mode, PasswordHash, Yescrypt};

#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Args {
    /// Hash the password read from STDIN
    #[arg(long = "hash", conflicts_with = "verify")]
    hash: bool,

    /// Verify the password read from STDIN using the salts passed as arguments
    #[arg(short = 'v', long = "verify", conflicts_with = "hash")]
    verify: bool,

    /// Salt 1 (works with verification only)
    #[arg(long, requires = "verify")]
    s1: Option<String>,

    /// Salt 2 (works with verification only)
    #[arg(long, requires = "verify")]
    s2: Option<String>,

    /// Password's hash (actually the MK's hash)
    #[arg(long, requires = "verify")]
    phash: Option<String>,
}
fn main() {
    let args = Args::parse();
    if args.hash && args.verify {
        eprintln!("Exactly either -h or -v must be specified.");
        std::process::exit(64);
    }
    // Read password from STDIN
    let password = readpw()
        .map_err(|e| {
            eprintln!("failed to read password: {}", e);
            std::process::exit(2);
        })
        .unwrap();

    if args.hash {
        hash_password(&password);
        std::process::exit(0);
    } else {
        let (s1, s2) = (args.s1.unwrap(), args.s2.unwrap());
        if s1.len() != 32 || s2.len() != 32 {
            eprintln!("The salts must be 32 characters long (16 bytes long)");
            std::process::exit(64);
        }
        let (salt1, salt2) = join(|| get_salt(s1), || get_salt(s2));
        verify_password(&password, &salt1, &salt2, args.phash.unwrap().as_str());
        std::process::exit(0);
    }
}

fn hash_password(password: &Vec<u8>) {
    let (salt1, (salt2, salt3)) = join(
        || generate_salt(),
        || join(|| generate_salt(), || generate_salt()),
    );

    // Hash the password
    let mk = derive_mk_dpk(&password, &salt1);
    let mk = mk.fields().last().unwrap().as_str();
    for b in salt1 {
        print!("{:02x}", b);
    }
    println!();

    // Hash the MK and derive the DPK:
    let (hash_mk, dpk) = join(|| mk_op(mk, &salt2), || mk_op(mk, &salt3));
    println!("{hash_mk}");
    for b in salt2 {
        print!("{:02x}", b);
    }
    println!();

    println!("{dpk}");
    for b in salt3 {
        print!("{:02x}", b);
    }
    println!();
}

fn verify_password(password: &Vec<u8>, salt1: &[u8], salt2: &[u8], phash: &str) {
    let mk = derive_mk_dpk(password, salt1);
    let mk = mk.fields().last().unwrap().as_str().as_bytes();
    let hash_mk = hash_mk(mk, salt2);
    let hash_mk = hash_mk.fields().last().unwrap().as_str();
    if hash_mk == phash {
        println!("Match");
        std::process::exit(0);
    } else {
        println!("Mismatch");
        std::process::exit(0);
    }
}

fn get_salt(salt: String) -> [u8; 16] {
    let mut s = [0u8; 16];
    for i in 0..16 {
        let byte = u8::from_str_radix(&salt[i * 2..i * 2 + 2], 16)
            .map_err(|_| "invalid hex")
            .unwrap();
        s[i] = byte;
    }

    s
}

fn readpw() -> Result<Vec<u8>, io::Error> {
    let mut buf = Vec::new();
    io::stdin().read_to_end(&mut buf)?;

    // Remove trailing newline(s)
    while matches!(buf.last(), Some(b'\n' | b'\r')) {
        buf.pop();
    }

    Ok(buf)
}

fn hash_mk(password: &[u8], salt: &[u8]) -> PasswordHash {
    let params =
        yescrypt::Params::new_with_all_params(Mode::default(), 32768, 32, 1, 0, 0).unwrap();
    Yescrypt
        .hash_password_with_params(password, &salt, params)
        .unwrap()
}

fn derive_mk_dpk(password: &[u8], salt: &[u8]) -> PasswordHash {
    let params = yescrypt::Params::new_with_all_params(Mode::default(), 4096, 32, 1, 0, 0).unwrap();
    Yescrypt
        .hash_password_with_params(&password, salt, params)
        .unwrap()
}

fn generate_salt() -> [u8; 16] {
    let mut salt = [0u8; 16];
    match OsRng.try_fill_bytes(&mut salt) {
        Ok(salt) => salt,
        Err(e) => {
            eprintln!("Error: {}", e);
            std::process::exit(2);
        }
    };
    salt
}

fn mk_op(mk: &str, salt: &[u8; 16]) -> String {
    let dgst = hash_mk(&mk.as_bytes(), salt);
    let dgst = dgst.fields().last().unwrap().as_str();
    format!("{dgst}")
}

